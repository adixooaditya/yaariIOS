//
//  ClosureHTTPManager.swift
//  MVCThreeMethods
//
//  Created by Steven Curtis on 12/04/2019.
//  Copyright © 2019 Steven Curtis. All rights reserved.
//

import Foundation
import KRProgressHUD
class HTTPManager {
    static let shared: HTTPManager = HTTPManager()
    let reachability = Reachability()!
    
    /// Errors that will be generated by the HTTPManager
    enum HTTPError: Error {
        case invalidURL
        case noInternet
        case invalidResponse(Data?, URLResponse?)
    }
    
    
    ///  Get data through an API call using a URL, returning a result type
    ///
    /// - Parameters:
    ///   - url: A URL represting the location of the resource
    ///   - completionBlock: A completion closure returning the result type
    //    public func get(url: URL, completionBlock: @escaping (Result<Data, Error>) -> Void) {
    //        // make sure we pull new data each time
    //        let request = URLRequest(url: url, cachePolicy: .reloadIgnoringLocalCacheData, timeoutInterval: 60)
    //        let session = URLSession.shared
    //        let task = session.dataTask(with: request) { data, response, error in
    //            guard error == nil else {
    //                completionBlock(.failure(error!))
    //                return
    //            }
    //
    //            guard
    //                let _ = data,
    //                let httpResponse = response as? HTTPURLResponse,
    //                200 ..< 300 ~= httpResponse.statusCode else {
    //                    if let data = data {
    //                        completionBlock(.success(data))
    //                    } else {
    //                        completionBlock(.failure(HTTPError.invalidResponse(data, response)))
    //                    }
    //                    return
    //            }
    //            // if passed guard
    //            if let data = data {
    //                completionBlock(.success(data))
    //            }
    //        }
    //        task.resume()
    //    }
    
    public func get(urlString: String, viewController:UIViewController,completionBlock: @escaping (Result<Data, Error>) -> Void) {
        print("URL \(urlString)")
        
        do {
            try reachability.startNotifier()
        }
        catch(let error) {
            print("error  +++  \(error.localizedDescription)")
        }
        
        if reachability.connection == .none {
            
            AlertManager.ShowAlertWithOk(title: "Alert", message: "No Internet Connection", presentedViewController:viewController)
            return
        }
        
        KRProgressHUD.show()
        
        guard let url = URL(string: urlString) else {
            completionBlock(.failure(HTTPError.invalidURL))
            
            return
        }
        let token = UserDefaults.standard.value(forKey: appConstants.loginToken) as! String
        let sessionConfig = URLSessionConfiguration.default
        sessionConfig.waitsForConnectivity = true
        sessionConfig.timeoutIntervalForRequest = 300
        sessionConfig.httpAdditionalHeaders = ["Authorization": token , "Content-Type":"application/json"]
        let session = URLSession(configuration: sessionConfig, delegate: self as? URLSessionDelegate, delegateQueue: nil)
        
        
        let task = session.dataTask(with: url) { data, response, error in
            guard error == nil else {
                completionBlock(.failure(error!))
                KRProgressHUD.dismiss()
                
                return
            }
            
            guard
                let responseData = data,
                let httpResponse = response as? HTTPURLResponse,
                200 ..< 300 ~= httpResponse.statusCode else {
                    completionBlock(.failure(HTTPError.invalidResponse(data, response)))
                    KRProgressHUD.dismiss()
                    
                    return
                }
            KRProgressHUD.dismiss()
            
            completionBlock(.success(responseData))
        }
        task.resume()
    }
    
    public func post(viewController:UIViewController, urlString: String,parameters:NSDictionary, completionBlock: @escaping (Result<Data, Error>) -> Void) {
        print(urlString)
        do {
            try reachability.startNotifier()
        }
        catch(let error) {
            print("error  +++  \(error.localizedDescription)")
        }
        
        if reachability.connection == .none {
            
            AlertManager.ShowAlertWithOk(title: "Alert", message: "No Internet Connection", presentedViewController:viewController)
            return
        }
        
        KRProgressHUD.show()
        
        guard let url = URL(string: urlString) else {
            completionBlock(.failure(HTTPError.invalidURL))
            KRProgressHUD.dismiss()
            
            return
        }
        
        
        
        var request = URLRequest(url: url, cachePolicy: .reloadIgnoringLocalCacheData, timeoutInterval: 60)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        let session = URLSession.shared
        
        if let jsonData =  try? JSONSerialization.data(withJSONObject:parameters, options:[]){
            let task = session.uploadTask(with: request, from: jsonData) { data, response, error in
                guard error == nil else {
                    KRProgressHUD.dismiss()
                    completionBlock(.failure(error!))
                    return
                }
                
                guard
                    let responseData = data,
                    let httpResponse = response as? HTTPURLResponse,
                    200 ..< 300 ~= httpResponse.statusCode else {
                        KRProgressHUD.dismiss()
                        
                        completionBlock(.failure(HTTPError.invalidResponse(data, response)))
                        return
                    }
                KRProgressHUD.dismiss()
                
                completionBlock(.success(responseData))
            }
            task.resume()
        }
    }
    public func postMutlipartData(viewController:UIViewController,httpMethod:String, urlString: String,parameters:NSDictionary, completionBlock: @escaping (Result<Data, Error>) -> Void) {
        print(urlString)
        do {
            try reachability.startNotifier()
        }
        catch(let error) {
            print("error \(error.localizedDescription)")
        }
        
        if reachability.connection == .none {
            
            AlertManager.ShowAlertWithOk(title: "Alert", message: "No Internet Connection", presentedViewController:viewController)
            return
        }
        
        KRProgressHUD.show()
        
        guard let url = URL(string: urlString) else {
            completionBlock(.failure(HTTPError.invalidURL))
            KRProgressHUD.dismiss()
            
            return
        }
        let token = UserDefaults.standard.value(forKey: appConstants.loginToken) as! String
        let sessionConfig = URLSessionConfiguration.default
        sessionConfig.waitsForConnectivity = true
        sessionConfig.timeoutIntervalForRequest = 300
        sessionConfig.httpAdditionalHeaders = ["Authorization": token , "Content-Type":"application/json"]
        let session = URLSession(configuration: sessionConfig, delegate: self as? URLSessionDelegate, delegateQueue: nil)
        
        
        var request = URLRequest(url: url, cachePolicy: .reloadIgnoringLocalCacheData, timeoutInterval: 60)
        request.httpMethod = httpMethod
        // request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        //        let boundary = "Boundary-\(UUID().uuidString)"
        //        request.setValue("multipart/form-data; boundary=\(boundary)", forHTTPHeaderField: "Content-Type")
        //        let mimeType = "image/jpg"
        //        var body = Data()
        //        let boundaryPrefix = " — \(boundary)\r\n"
        //
        //        for (key, value) in parameters {
        //        body.append(string: boundaryPrefix)
        //        body.append(string: "Content-Disposition: form-data; name=\"\(key)\"\r\n\r\n")
        //        body.append(string: "\(value)\r\n")
        //        }
        //
        //        let imageData = image.jpegData(compressionQuality: 1.0)
        //        let filename = "image1"
        //
        //        body.append(string: boundaryPrefix)
        //        body.append(string: "Content-Disposition: form-data; name=\"image\"; filename=\"\(filename)\"\r\n")
        //        body.append(string: "Content-Type: \(mimeType)\r\n\r\n")
        //        body.append(imageData!)
        //        body.append(string: "\r\n")
        //        body.append(string: " — ".appending(boundary.appending(" — ")))
        //
        //        request.httpBody = body
        // let session = URLSession.shared
        
        // if let jsonData =  try? JSONSerialization.data(withJSONObject:parameters, options:[]){
        //            let task = session.dataTask(with: request) { data, response, error in
        //               guard error == nil else {
        //                   KRProgressHUD.dismiss()
        //                completionBlock(.failure(error!))
        //                   return
        //               }
        //
        //               guard
        //                   let responseData = data,
        //                   let httpResponse = response as? HTTPURLResponse,
        //                   200 ..< 300 ~= httpResponse.statusCode else {
        //                       KRProgressHUD.dismiss()
        //
        //                       completionBlock(.failure(HTTPError.invalidResponse(data, response)))
        //                       return
        //               }
        //                KRProgressHUD.dismiss()
        //
        //               completionBlock(.success(responseData))
        //           }
        //           task.resume()
        
        if let jsonData =  try? JSONSerialization.data(withJSONObject:parameters, options:[]){
            let task = session.uploadTask(with: request, from: jsonData) { data, response, error in
                guard error == nil else {
                    KRProgressHUD.dismiss()
                    completionBlock(.failure(error!))
                    return
                }
                
                guard
                    let responseData = data,
                    let httpResponse = response as? HTTPURLResponse,
                    200 ..< 300 ~= httpResponse.statusCode else {
                        KRProgressHUD.dismiss()
                        
                        completionBlock(.failure(HTTPError.invalidResponse(data, response)))
                        return
                    }
                KRProgressHUD.dismiss()
                
                completionBlock(.success(responseData))
            }
            task.resume()
        }
        
        
        //}
    }
    
    public func postWithAuth(viewController:UIViewController,httpMethod:String, urlString: String,parameters:NSDictionary, completionBlock: @escaping (Result<Data, Error>) -> Void) {
        print(urlString)
        do {
            try reachability.startNotifier()
        }
        catch(let error) {
            print("error \(error.localizedDescription)")
        }
        
        if reachability.connection == .none {
            
            AlertManager.ShowAlertWithOk(title: "Alert", message: "No Internet Connection", presentedViewController:viewController)
            return
        }
        
        KRProgressHUD.show()
        
        guard let url = URL(string: urlString) else {
            completionBlock(.failure(HTTPError.invalidURL))
            KRProgressHUD.dismiss()
            
            return
        }
        let token = UserDefaults.standard.value(forKey: appConstants.loginToken) as! String
        let sessionConfig = URLSessionConfiguration.default
        sessionConfig.waitsForConnectivity = true
        sessionConfig.timeoutIntervalForRequest = 300
        sessionConfig.httpAdditionalHeaders = ["Authorization": token , "Content-Type":"application/json"]
        let session = URLSession(configuration: sessionConfig, delegate: self as? URLSessionDelegate, delegateQueue: nil)
        
        
        var request = URLRequest(url: url, cachePolicy: .reloadIgnoringLocalCacheData, timeoutInterval: 60)
        request.httpMethod = httpMethod
        
        
        if let jsonData =  try? JSONSerialization.data(withJSONObject:parameters, options:[]){
            let task = session.uploadTask(with: request, from: jsonData) { data, response, error in
                guard error == nil else {
                    KRProgressHUD.dismiss()
                    completionBlock(.failure(error!))
                    return
                }
                
                guard
                    let responseData = data,
                    let httpResponse = response as? HTTPURLResponse,
                    200 ..< 300 ~= httpResponse.statusCode else {
                        KRProgressHUD.dismiss()
                        
                        completionBlock(.failure(HTTPError.invalidResponse(data, response)))
                        return
                    }
                KRProgressHUD.dismiss()
                
                completionBlock(.success(responseData))
            }
            task.resume()
        }
        
        
        //}
    }
    
    
    
    public func delete(viewController:UIViewController, urlString: String, completionBlock: @escaping (Result<Data, Error>) -> Void) {
        print(urlString)
        do {
            try reachability.startNotifier()
        }
        catch(let error) {
            print("error \(error.localizedDescription)")
        }
        
        if reachability.connection == .none {
            
            AlertManager.ShowAlertWithOk(title: "Alert", message: "No Internet Connection", presentedViewController:viewController)
            return
        }
        
        KRProgressHUD.show()
        
        guard let url = URL(string: urlString) else {
            completionBlock(.failure(HTTPError.invalidURL))
            KRProgressHUD.dismiss()
            
            return
        }
        let token = UserDefaults.standard.value(forKey: appConstants.loginToken) as! String
        
        var request = URLRequest(url: url, cachePolicy: .reloadIgnoringLocalCacheData, timeoutInterval: 60)
        request.httpMethod = "DELETE"
        //        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        //        request.setValue(token, forHTTPHeaderField: "Authorization")
        //        let session = URLSession.shared
        
        let sessionConfig = URLSessionConfiguration.default
        sessionConfig.waitsForConnectivity = true
        
        //zxjby,ki'sessionConfig.timeoutIntervalForRequest = 300
        sessionConfig.httpAdditionalHeaders = ["Authorization": token , "Content-Type":"application/json"]
        let session = URLSession(configuration: sessionConfig, delegate: self as? URLSessionDelegate, delegateQueue: nil)
        
        
        
        let task = session.dataTask(with: request) { data, response, error in
            guard error == nil else {
                completionBlock(.failure(error!))
                KRProgressHUD.dismiss()
                return
            }
            
            guard
                let responseData = data,
                let httpResponse = response as? HTTPURLResponse,
                200 ..< 300 ~= httpResponse.statusCode else {
                    completionBlock(.failure(HTTPError.invalidResponse(data, response)))
                    KRProgressHUD.dismiss()
                    return
                }
            KRProgressHUD.dismiss()
            completionBlock(.success(responseData))
        }
        task.resume()
    }
    
}
extension Data {
    mutating func append(string: String) {
        let data = string.data(
            using: String.Encoding.utf8,
            allowLossyConversion: true)
        append(data!)
    }
}
